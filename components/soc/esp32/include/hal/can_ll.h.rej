diff a/components/soc/esp32/include/hal/can_ll.h b/components/soc/esp32/include/hal/can_ll.h	(rejected hunks)
@@ -33,22 +33,22 @@ extern "C" {
 
 /* ------------------------- Defines and Typedefs --------------------------- */
 
-#define CAN_LL_STATUS_RBS       (0x1 << 0)
-#define CAN_LL_STATUS_DOS       (0x1 << 1)
-#define CAN_LL_STATUS_TBS       (0x1 << 2)
-#define CAN_LL_STATUS_TCS       (0x1 << 3)
-#define CAN_LL_STATUS_RS        (0x1 << 4)
-#define CAN_LL_STATUS_TS        (0x1 << 5)
-#define CAN_LL_STATUS_ES        (0x1 << 6)
-#define CAN_LL_STATUS_BS        (0x1 << 7)
-
-#define CAN_LL_INTR_RI          (0x1 << 0)
-#define CAN_LL_INTR_TI          (0x1 << 1)
-#define CAN_LL_INTR_EI          (0x1 << 2)
+#define CAN_LL_STATUS_RBS       (0x1 << 0)  //Receive Buffer Status 
+#define CAN_LL_STATUS_DOS       (0x1 << 1)  //Data Overrun Status
+#define CAN_LL_STATUS_TBS       (0x1 << 2)  //Transmit Buffer Status
+#define CAN_LL_STATUS_TCS       (0x1 << 3)  //Transmission Complete Status
+#define CAN_LL_STATUS_RS        (0x1 << 4)  //Receive Status
+#define CAN_LL_STATUS_TS        (0x1 << 5)  //Transmit Status
+#define CAN_LL_STATUS_ES        (0x1 << 6)  //Error Status
+#define CAN_LL_STATUS_BS        (0x1 << 7)  //Bus Status
+
+#define CAN_LL_INTR_RI          (0x1 << 0)  //Receive Interrupt
+#define CAN_LL_INTR_TI          (0x1 << 1)  //Transmit Interrupt
+#define CAN_LL_INTR_EI          (0x1 << 2)  //Error Interrupt
 //Data overrun interrupt not supported in SW due to HW peculiarities
-#define CAN_LL_INTR_EPI         (0x1 << 5)
-#define CAN_LL_INTR_ALI         (0x1 << 6)
-#define CAN_LL_INTR_BEI         (0x1 << 7)
+#define CAN_LL_INTR_EPI         (0x1 << 5)  //Error Passive Interrupt
+#define CAN_LL_INTR_ALI         (0x1 << 6)  //Arbitration Lost Interrupt
+#define CAN_LL_INTR_BEI         (0x1 << 7)  //Bus Error Interrupt
 
 /*
  * The following frame structure has an NEARLY identical bit field layout to
@@ -82,6 +82,68 @@ typedef union {
     uint8_t bytes[13];
 } __attribute__((packed)) can_ll_frame_buffer_t;
 
+#ifdef CAN_ERRATA_HW_RESET_PERIPH
+/**
+ * Some errata workarounds will require a hardware reset of the peripheral. Thus
+ * certain registers must be saved before the reset, and then restored after the
+ * reset. This structure is used to hold some of those registers. 
+ */
+typedef struct {
+    uint8_t mode_reg;
+    uint8_t interrupt_enable_reg;
+    uint8_t bus_timing_0_reg;
+    uint8_t bus_timing_1_reg;
+    uint8_t error_warning_limit_reg;
+    uint8_t acr_reg[4];
+    uint8_t amr_reg[4];
+    uint8_t rx_error_counter_reg;
+    uint8_t tx_error_counter_reg;
+    uint8_t clock_divider_reg;
+} __attribute__((packed)) can_ll_reg_save_t;
+#endif
+
+typedef enum {
+    CAN_LL_ERR_BIT = 0,
+    CAN_LL_ERR_FORM,
+    CAN_LL_ERR_STUFF,
+    CAN_LL_ERR_OTHER,
+    CAN_LL_ERR_MAX,
+} can_ll_err_type_t;
+
+typedef enum {
+    CAN_LL_ERR_DIR_TX = 0,
+    CAN_LL_ERR_DIR_RX,
+    CAN_LL_ERR_DIR_MAX,
+} can_ll_err_dir_t;
+
+typedef enum {
+    CAN_LL_ERR_SEG_SOF = 0,
+    CAN_LL_ERR_SEG_ID_28_21 = 2,
+    CAN_LL_ERR_SEG_SRTR = 4,
+    CAN_LL_ERR_SEG_IDE = 5,
+    CAN_LL_ERR_SEG_ID_20_18 = 6,
+    CAN_LL_ERR_SEG_ID_17_13 = 7,
+    CAN_LL_ERR_SEG_CRC_SEQ = 8,
+    CAN_LL_ERR_SEG_R0 = 9,
+    CAN_LL_ERR_SEG_DATA = 10,
+    CAN_LL_ERR_SEG_DLC = 11,
+    CAN_LL_ERR_SEG_RTR = 12,
+    CAN_LL_ERR_SEG_R1 = 13,
+    CAN_LL_ERR_SEG_ID_4_0 = 14,
+    CAN_LL_ERR_SEG_ID_12_5 = 15,
+    CAN_LL_ERR_SEG_ACT_FLAG = 17,
+    CAN_LL_ERR_SEG_INTER = 18,
+    CAN_LL_ERR_SEG_SUPERPOS = 19,
+    CAN_LL_ERR_SEG_PASS_FLAG = 22,
+    CAN_LL_ERR_SEG_ERR_DELIM = 23,
+    CAN_LL_ERR_SEG_CRC_DELIM = 24,
+    CAN_LL_ERR_SEG_ACK_SLOT = 25,
+    CAN_LL_ERR_SEG_EOF = 26,
+    CAN_LL_ERR_SEG_ACK_DELIM = 27,
+    CAN_LL_ERR_SEG_OVRLD_FLAG = 28,
+    CAN_LL_ERR_SEG_MAX = 29,
+} can_ll_err_seg_t;
+
 /* ---------------------------- Mode Register ------------------------------- */
 
 /**
@@ -377,31 +439,52 @@ static inline void can_ll_set_bus_timing(can_dev_t *hw, uint32_t brp, uint32_t s
 /* ----------------------------- ALC Register ------------------------------- */
 
 /**
- * @brief   Clear Arbitration Lost Capture Register
+ * @brief   Read the Arbitration Lost Capture Register
  *
- * Reading the ALC register rearms the Arbitration Lost Interrupt
+ * Reading the ALC register automatically clears it and also rearms the
+ * Arbitration Lost Interrupt
  *
  * @param hw Start address of the CAN registers
+ * @return ALC register
  */
-static inline void can_ll_clear_arb_lost_cap(can_dev_t *hw)
+static inline uint32_t can_ll_get_arb_lost_cap(can_dev_t *hw)
 {
-    (void)hw->arbitration_lost_captue_reg.val;
-    //Todo: Decode ALC register
+    return hw->arbitration_lost_captue_reg.val;
 }
 
 /* ----------------------------- ECC Register ------------------------------- */
 
 /**
- * @brief   Clear Error Code Capture register
+ * @brief   Read the Error Code Capture register
  *
- * Reading the ECC register rearms the Bus Error Interrupt
+ * Reading the ECC register automatically clears it and also rearms the Bus 
+ * Error Interrupt.
  *
  * @param hw Start address of the CAN registers
+ * @return ECC register
+ */
+static inline uint32_t can_ll_get_err_code_cap(can_dev_t *hw)
+{
+    return hw->error_code_capture_reg.val;
+}
+
+/**
+ * @brief   Decode the Error Code Capture register
+ *
+ * Decodes the contents of the Error Code Capture register to determine details
+ * regarding the captured bus error.
+ *
+ * @param ecc[in] Value of ECC register
+ * @param type[out] Type of bus error
+ * @param dir[out] Direction when error occurred
+ * @param seg[out] Segment where error occurred
  */
-static inline void can_ll_clear_err_code_cap(can_dev_t *hw)
+static inline void can_ll_decode_err_code_cap(uint32_t ecc, can_ll_err_type_t *type, can_ll_err_dir_t *dir, can_ll_err_seg_t *seg)
 {
-    (void)hw->error_code_capture_reg.val;
-    //Todo: Decode error code capture
+    //Decode ECC register fields
+    *type = (can_ll_err_type_t) ((ecc >> 6) & 0x3);
+    *dir = (can_ll_err_dir_t) ((ecc >> 5) & 0x1);
+    *seg = (can_ll_err_seg_t) (ecc & 0x1F);
 }
 
 /* ----------------------------- EWL Register ------------------------------- */
@@ -698,6 +781,60 @@ static inline void can_ll_enable_extended_reg_layout(can_dev_t *hw)
     hw->clock_divider_reg.cm = 1;
 }
 
+#ifdef CAN_ERRATA_HW_RESET_PERIPH
+/**
+ * @brief   Saves the current values of the controller's registers
+ * 
+ * This function saves the current values of the controller's registers in
+ * preparation for a hardware reset of the peripheral.
+ * 
+ * @param hw Start address of the CAN registers
+ * @param reg_save Pointer to structure to store register values
+ * @note Must be called in reset mode so that config registers become accessible.
+ * @note Some registers are cleared on entering reset mode so must be saved
+ *       separate from this function.
+ */
+static inline void can_ll_save_reg(can_dev_t *hw, can_ll_reg_save_t *reg_save)
+{
+    reg_save->mode_reg = (uint8_t) hw->mode_reg.val;
+    reg_save->interrupt_enable_reg = (uint8_t) hw->interrupt_enable_reg.val;
+    reg_save->bus_timing_0_reg = (uint8_t) hw->bus_timing_0_reg.val;
+    reg_save->bus_timing_1_reg = (uint8_t) hw->bus_timing_1_reg.val;
+    reg_save->error_warning_limit_reg = (uint8_t) hw->error_warning_limit_reg.val;
+    for (int i = 0; i < 4; i++) {
+        reg_save->acr_reg[i] = hw->acceptance_filter.acr[i].byte;
+        reg_save->amr_reg[i] = hw->acceptance_filter.amr[i].byte;
+    }
+    reg_save->rx_error_counter_reg = (uint8_t) hw->rx_error_counter_reg.val;
+    reg_save->tx_error_counter_reg = (uint8_t) hw->tx_error_counter_reg.val;
+    reg_save->clock_divider_reg = (uint8_t) hw->clock_divider_reg.val;
+}
+
+/**
+ * @brief   Restores the previous values of the controller's registers
+ * 
+ * @param hw Start address of the CAN registers
+ * @param reg_save Pointer to structure to storing register values to restore
+ * @note Must be called in reset mode so that config registers become accessible
+ * @note Some registers are read only thus cannot be restored
+ */
+static inline void can_ll_restore_reg(can_dev_t *hw, can_ll_reg_save_t *reg_save)
+{
+    hw->mode_reg.val = reg_save->mode_reg;
+    hw->interrupt_enable_reg.val = reg_save->interrupt_enable_reg;
+    hw->bus_timing_0_reg.val = reg_save->bus_timing_0_reg;
+    hw->bus_timing_1_reg.val = reg_save->bus_timing_1_reg;
+    hw->error_warning_limit_reg.val = reg_save->error_warning_limit_reg;
+    for (int i = 0; i < 4; i++) {
+        hw->acceptance_filter.acr[i].byte = reg_save->acr_reg[i];
+        hw->acceptance_filter.amr[i].byte = reg_save->amr_reg[i];
+    }
+    hw->rx_error_counter_reg.val = reg_save->rx_error_counter_reg;
+    hw->tx_error_counter_reg.val = reg_save->tx_error_counter_reg;
+    hw->clock_divider_reg.val = reg_save->clock_divider_reg;
+}
+#endif
+
 #ifdef __cplusplus
 }
 #endif
